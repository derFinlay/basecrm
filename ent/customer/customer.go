// Code generated by ent, DO NOT EDIT.

package customer

import (
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the customer type in the database.
	Label = "customer"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldGender holds the string denoting the gender field in the database.
	FieldGender = "gender"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// EdgeOrders holds the string denoting the orders edge name in mutations.
	EdgeOrders = "orders"
	// EdgeBillingAddresses holds the string denoting the billing_addresses edge name in mutations.
	EdgeBillingAddresses = "billing_addresses"
	// EdgeDeliveryAddresses holds the string denoting the delivery_addresses edge name in mutations.
	EdgeDeliveryAddresses = "delivery_addresses"
	// EdgeTels holds the string denoting the tels edge name in mutations.
	EdgeTels = "tels"
	// EdgeCreatedBy holds the string denoting the created_by edge name in mutations.
	EdgeCreatedBy = "created_by"
	// EdgeNotes holds the string denoting the notes edge name in mutations.
	EdgeNotes = "notes"
	// EdgeLogin holds the string denoting the login edge name in mutations.
	EdgeLogin = "login"
	// Table holds the table name of the customer in the database.
	Table = "customers"
	// OrdersTable is the table that holds the orders relation/edge.
	OrdersTable = "orders"
	// OrdersInverseTable is the table name for the Order entity.
	// It exists in this package in order to avoid circular dependency with the "order" package.
	OrdersInverseTable = "orders"
	// OrdersColumn is the table column denoting the orders relation/edge.
	OrdersColumn = "customer_orders"
	// BillingAddressesTable is the table that holds the billing_addresses relation/edge.
	BillingAddressesTable = "billing_addresses"
	// BillingAddressesInverseTable is the table name for the BillingAddress entity.
	// It exists in this package in order to avoid circular dependency with the "billingaddress" package.
	BillingAddressesInverseTable = "billing_addresses"
	// BillingAddressesColumn is the table column denoting the billing_addresses relation/edge.
	BillingAddressesColumn = "customer_billing_addresses"
	// DeliveryAddressesTable is the table that holds the delivery_addresses relation/edge.
	DeliveryAddressesTable = "delivery_addresses"
	// DeliveryAddressesInverseTable is the table name for the DeliveryAddress entity.
	// It exists in this package in order to avoid circular dependency with the "deliveryaddress" package.
	DeliveryAddressesInverseTable = "delivery_addresses"
	// DeliveryAddressesColumn is the table column denoting the delivery_addresses relation/edge.
	DeliveryAddressesColumn = "customer_delivery_addresses"
	// TelsTable is the table that holds the tels relation/edge.
	TelsTable = "tels"
	// TelsInverseTable is the table name for the Tel entity.
	// It exists in this package in order to avoid circular dependency with the "tel" package.
	TelsInverseTable = "tels"
	// TelsColumn is the table column denoting the tels relation/edge.
	TelsColumn = "customer_tels"
	// CreatedByTable is the table that holds the created_by relation/edge.
	CreatedByTable = "customers"
	// CreatedByInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	CreatedByInverseTable = "users"
	// CreatedByColumn is the table column denoting the created_by relation/edge.
	CreatedByColumn = "customer_created_by"
	// NotesTable is the table that holds the notes relation/edge.
	NotesTable = "notes"
	// NotesInverseTable is the table name for the Note entity.
	// It exists in this package in order to avoid circular dependency with the "note" package.
	NotesInverseTable = "notes"
	// NotesColumn is the table column denoting the notes relation/edge.
	NotesColumn = "customer_notes"
	// LoginTable is the table that holds the login relation/edge.
	LoginTable = "logins"
	// LoginInverseTable is the table name for the Login entity.
	// It exists in this package in order to avoid circular dependency with the "login" package.
	LoginInverseTable = "logins"
	// LoginColumn is the table column denoting the login relation/edge.
	LoginColumn = "customer_login"
)

// Columns holds all SQL columns for customer fields.
var Columns = []string{
	FieldID,
	FieldName,
	FieldGender,
	FieldCreatedAt,
	FieldUpdatedAt,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "customers"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"customer_created_by",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// NameValidator is a validator for the "name" field. It is called by the builders before save.
	NameValidator func(string) error
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
	// UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
	UpdateDefaultUpdatedAt func() time.Time
)

// Gender defines the type for the "gender" enum field.
type Gender string

// Gender values.
const (
	GenderC Gender = "c"
	GenderM Gender = "m"
	GenderF Gender = "f"
	GenderD Gender = "d"
)

func (ge Gender) String() string {
	return string(ge)
}

// GenderValidator is a validator for the "gender" field enum values. It is called by the builders before save.
func GenderValidator(ge Gender) error {
	switch ge {
	case GenderC, GenderM, GenderF, GenderD:
		return nil
	default:
		return fmt.Errorf("customer: invalid enum value for gender field: %q", ge)
	}
}

// OrderOption defines the ordering options for the Customer queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByGender orders the results by the gender field.
func ByGender(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldGender, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByOrdersCount orders the results by orders count.
func ByOrdersCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newOrdersStep(), opts...)
	}
}

// ByOrders orders the results by orders terms.
func ByOrders(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newOrdersStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByBillingAddressesCount orders the results by billing_addresses count.
func ByBillingAddressesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newBillingAddressesStep(), opts...)
	}
}

// ByBillingAddresses orders the results by billing_addresses terms.
func ByBillingAddresses(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newBillingAddressesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByDeliveryAddressesCount orders the results by delivery_addresses count.
func ByDeliveryAddressesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newDeliveryAddressesStep(), opts...)
	}
}

// ByDeliveryAddresses orders the results by delivery_addresses terms.
func ByDeliveryAddresses(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newDeliveryAddressesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByTelsCount orders the results by tels count.
func ByTelsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newTelsStep(), opts...)
	}
}

// ByTels orders the results by tels terms.
func ByTels(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTelsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByCreatedByField orders the results by created_by field.
func ByCreatedByField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCreatedByStep(), sql.OrderByField(field, opts...))
	}
}

// ByNotesCount orders the results by notes count.
func ByNotesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newNotesStep(), opts...)
	}
}

// ByNotes orders the results by notes terms.
func ByNotes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newNotesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByLoginField orders the results by login field.
func ByLoginField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newLoginStep(), sql.OrderByField(field, opts...))
	}
}
func newOrdersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(OrdersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, OrdersTable, OrdersColumn),
	)
}
func newBillingAddressesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(BillingAddressesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, BillingAddressesTable, BillingAddressesColumn),
	)
}
func newDeliveryAddressesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(DeliveryAddressesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, DeliveryAddressesTable, DeliveryAddressesColumn),
	)
}
func newTelsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TelsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, TelsTable, TelsColumn),
	)
}
func newCreatedByStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CreatedByInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, CreatedByTable, CreatedByColumn),
	)
}
func newNotesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(NotesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, NotesTable, NotesColumn),
	)
}
func newLoginStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(LoginInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, false, LoginTable, LoginColumn),
	)
}
